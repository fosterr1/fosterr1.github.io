---
layout: default
---
<h1>Reid Foster</h1>
<p>Blog for CSCI 362.</p>
<h2>HW0: Introduction</h2>
<p>I am from Hilton Head Island and am a third year Computer Science major at the College of Charleston.</p>
<h2>HW1: Chapter 1</h2>
<h3>1.3</h3>
<p>A software should have the attributes of acceptability, dependability and security, efficiency, and maintainability.  Other attributes that are beneficial to software are: compatibility to work on several different devices, scalability to be able to apply the functions of the software to a wide array of different things, portability to move the software and its data to another device, and upgradability to be able to update the software with new functions and fix bugs in an efficient manner.</p>
<h3>1.8</h3>
<p>The problem with licensing software engineers in the same way as doctors and lawyers is that many software engineers are self-taught to great effect and should not be discounted.  There is also already the fact that those with a degree or other certificate of training are already boosted in the view of employers as they already have that certainty of training unlike those who are self-taught.</p>
<h3>1.9</h3>
<p>1. Engineers should not intentionally hide information on what a software may do such as data collection.</p>
<p>2. Engineers should not put any backdoors or such in a system they are working on to later use themselves against a client.</p>
<p>3.  Engineers should ensure the security of a system such that hackers could not take advantage of it.</p>
<p>4. Engineers should not leak any confidential data for their own gain or the express intent of hurting the client.</p>
<p>5.  Managers should abstain from unjust work practices such as intense crunch time to finish a product.</p>
<p>6.  Engineers should act in a way that does not make the profession seem completely immoral such as working for an immoral employer.</p>
<p>7.  Engineers should not blame mistakes on colleagues unjustly to get ahead.</p>
<p>8.  Engineers should always be learning such to improve their work and get ahead of new security threats and the like.</p>
<h3>1.10</h3>
<p>The ethics involved in the creation of a system to constantly track citizens is essentially none.  The excuse of “fighting terrorism” can be used to drastically increase control over people and their daily lives.  Even if the morals of the users are completely just, the possibility of a malicious user is more than enough reason to not create a system that can be taken advantage of to a drastic degree. </p>
<h2>HW2: Reflections on software engineering practices</h2>
<p>	The overarching problem throughout software development history is the extreme complexity in the creations of new systems.  It is a constant struggle to find new ways to reduce this complexity without losing something else along the way.  As seen in Brooks’s 1986 article, “No Silver Bullet,” many of the problems we face today in software engineering have been there since the very beginning.  The progression from the beginning to now can be seen in Potvin and Levenberg’s, “Why Google Stores Billions of Lines of Code in a Single Repository,” as while many issues have been solved by modern advances, the core problems of software engineering have only been scaled up to the monolithic projects of today such as Google.
	As Brooks argues, complexity is inherent in the field of software engineering due to its uniqueness.  Because of this, software falls behind the incredible growth of computer hardware according to Moore’s Law.  And while computer hardware grows at an incredible rate compared to any field, software development continues slowly as it is quite unique compared to most anything else.  This is due to the difficulties that arise in the conception of software.  Most software has many unique elements that interact with each other in a nonlinear fashion, making visualization of software incredibly difficult.  This inherent “unvisualization” as Brooks calls it is why software engineering is so different than the development of other fields.  The development of things other than software almost always have a visualization and modeling step to plan the future steps of the project from the very beginning so that one understands the goals of the project.  This uniqueness hinders the conception of software and lends heavily to the inherent complexity of the field.
	This complexity of non-linear interaction is seen on a terrific scale with the billions of lines of code seen in Google’s repository.  While there are many employees to comb through this code and automated systems set up for maintenance of this huge structure, complex problems are bound to happen this this large of a system.  Code-discovery is inherently difficult as many things that may have already been written could be rewritten somewhere else by one who does not know of the other’s existence in the billions of lines of code, wasting time and space.  And when code is found a large unwieldy web of dependencies can be formed through the interaction of all the code found within the structure.  This is somewhat alleviated with automated systems and code review to help ensure clean code alongside truck-based development to always keep everyone up to date on system changes.
	In Neville-Neil’s “Cherry-Picking and the Scientific Method,” he makes two points about having small incremental merges rather than a single large one and approaching bug fixing like the scientific method with written thoughts on the problem.  These types of development philosophies can be seen on a large scale with Google’s repository and their trunk-based development to keep all employees up to speed with code changes.  This along with their automated systems of maintenance follow along with Brooks and his predictions for possible solutions to help alleviate software development complexity on a large scale as seen in the modern day.
</p>
