---
layout: default
---
<h1>Reid Foster</h1>
<p>Blog for CSCI 362.</p>
<h2>HW0: Introduction</h2>
<p>I am from Hilton Head Island and am a third year Computer Science major at the College of Charleston.</p>
<h2>HW1: Chapter 1</h2>
<h3>1.3</h3>
<p>A software should have the attributes of acceptability, dependability and security, efficiency, and maintainability.  Other attributes that are beneficial to software are: compatibility to work on several different devices, scalability to be able to apply the functions of the software to a wide array of different things, portability to move the software and its data to another device, and upgradability to be able to update the software with new functions and fix bugs in an efficient manner.</p>
<h3>1.8</h3>
<p>The problem with licensing software engineers in the same way as doctors and lawyers is that many software engineers are self-taught to great effect and should not be discounted.  There is also already the fact that those with a degree or other certificate of training are already boosted in the view of employers as they already have that certainty of training unlike those who are self-taught.</p>
<h3>1.9</h3>
<p>1. Engineers should not intentionally hide information on what a software may do such as data collection.</p>
<p>2. Engineers should not put any backdoors or such in a system they are working on to later use themselves against a client.</p>
<p>3.  Engineers should ensure the security of a system such that hackers could not take advantage of it.</p>
<p>4. Engineers should not leak any confidential data for their own gain or the express intent of hurting the client.</p>
<p>5.  Managers should abstain from unjust work practices such as intense crunch time to finish a product.</p>
<p>6.  Engineers should act in a way that does not make the profession seem completely immoral such as working for an immoral employer.</p>
<p>7.  Engineers should not blame mistakes on colleagues unjustly to get ahead.</p>
<p>8.  Engineers should always be learning such to improve their work and get ahead of new security threats and the like.</p>
<h3>1.10</h3>
<p>The ethics involved in the creation of a system to constantly track citizens is essentially none.  The excuse of “fighting terrorism” can be used to drastically increase control over people and their daily lives.  Even if the morals of the users are completely just, the possibility of a malicious user is more than enough reason to not create a system that can be taken advantage of to a drastic degree. </p>
<h2>HW2: Reflections on software engineering practices</h2>
<p>The overarching problem throughout software development history is the extreme complexity in the creations of new systems.  It is a constant struggle to find new ways to reduce this complexity without losing something else along the way.  As seen in Brooks’s 1986 article, “No Silver Bullet,” many of the problems we face today in software engineering have been there since the very beginning.  The progression from the beginning to now can be seen in Potvin and Levenberg’s, “Why Google Stores Billions of Lines of Code in a Single Repository,” as while many issues have been solved by modern advances, the core problems of software engineering have only been scaled up to the monolithic projects of today such as Google.</p>
<p>As Brooks argues, complexity is inherent in the field of software engineering due to its uniqueness.  Because of this, software falls behind the incredible growth of computer hardware according to Moore’s Law.  And while computer hardware grows at an incredible rate compared to any field, software development continues slowly as it is quite unique compared to most anything else.  This is due to the difficulties that arise in the conception of software.  Most software has many unique elements that interact with each other in a nonlinear fashion, making visualization of software incredibly difficult.  This inherent “unvisualization” as Brooks calls it is why software engineering is so different than the development of other fields.  The development of things other than software almost always have a visualization and modeling step to plan the future steps of the project from the very beginning so that one understands the goals of the project.  This uniqueness hinders the conception of software and lends heavily to the inherent complexity of the field.</p>
<p>This complexity of non-linear interaction is seen on a terrific scale with the billions of lines of code seen in Google’s repository.  While there are many employees to comb through this code and automated systems set up for maintenance of this huge structure, complex problems are bound to happen this this large of a system.  Code-discovery is inherently difficult as many things that may have already been written could be rewritten somewhere else by one who does not know of the other’s existence in the billions of lines of code, wasting time and space.  And when code is found a large unwieldy web of dependencies can be formed through the interaction of all the code found within the structure.  This is somewhat alleviated with automated systems and code review to help ensure clean code alongside truck-based development to always keep everyone up to date on system changes.</p>
<p>In Neville-Neil’s “Cherry-Picking and the Scientific Method,” he makes two points about having small incremental merges rather than a single large one and approaching bug fixing like the scientific method with written thoughts on the problem.  These types of development philosophies can be seen on a large scale with Google’s repository and their trunk-based development to keep all employees up to speed with code changes.  This along with their automated systems of maintenance follow along with Brooks and his predictions for possible solutions to help alleviate software development complexity on a large scale as seen in the modern day.</p>
<h2>HW3: Chapters 11 & 12</h2>
<h3>11.4</h3>
<p>Architectural styles that are geared toward software fault tolerance all rely on some level of redundancy and software diversity.  This greatly improves reliability in the event of a system failure where there will be a transfer to a different system.</p>
<h3>11.7</h3>
<p>N-version programming would be useful for a critical machine such as one used for radiation therapy because in the event of a system failure the others can be relied on.  There is also some amount of self-moderation through the voting system that compares the outputs of each software diverse system to help ensure the correct output.</p>
<h3>11.9</h3>
<p>You should handle all exceptions in a system to ensure availability as otherwise a system fault is inevitable.  Handling exceptions will greatly reduce the number of possible system faults and keep the system available, otherwise, an exception could cause the system to fail and need to be fixed, leading to a large impact on availability.</p>
<h3>12.5</h3>
<p>Based off of these specifications, some system requirements for this software could be:  determine at what distance and rate the breaks should be applied to ensure a steady ride without extreme stops, make sure transmissions have a fast refresh rate to ensure that information on the system is current and correct, calculate routes based off of speed limits and signal status, decrease acceleration when approaching the speed limit, and be able to receive special warnings about any other dangers that require slowing or stopping the train.</p>
<h2>HW4: Reflections on software failures</h2>
<p>While software has been a great boon in the advancement of technology, this overreliance has led to many catastrophic accidents.  This overreliance has led to overconfidence on several occasions, further leading to general disregard for good software engineering practices.  Even in systems where the reliability of the software is paramount for the safety of many, this disregard can be seen.  Often the ignorance towards productive software development leads to many problems, such as: poor management, buggy, poorly tested code, a complete lack of documentation for later analysis, a rushed schedule, teams that are too small and overworked, and more.</p>
<p>One example of the overreliance and overconfidence in software is the Therac-25 accidents which led to several injuries and deaths.  This overconfidence led to the removal of the hardware safety features in this new machine.  However, the software was based off these previous versions that had the hardware safety features, and as it turns out, this software already had bugs that went unnoticed because they were previously covered by hardware mechanisms.  Not only that, there was supposedly only one developer who could not be discovered after the accidents.  The resulting code was severely lacking documentation.  And when engineers tested the machines, the software was an afterthought and essentially ignored.</p>
<p>This relates to another issue, the lack of proper user interface development.  With the Therac-25 case in the 1980s and the one of overdosing CT scans in the 2000s, both had user interface problems which further exacerbated the problems.  Both cases had several examples in which the operators of the machines did not have a substantial amount of information on how to properly manage the systems, with severely lackluster manuals.  There were error codes with no explanations that also had no indications of how dangerous it was.  Along with that, the CT scans had an automatic feature that raised the dosage on a patient due to improper explanation of its intended function.  This total disregard for a clear interface on a system so crucial is a major oversight.</p>
<p>Perhaps the most important thing that was ignored in these cases was proper management to ensure a healthy development cycle.  This can be seen no better than in the FBI’s transitioning to an electronic case system.  After 9/11, the FBI’s system of information was seen to be extremely lacking and was obvious in need of a substantial overhaul.  This rush for a new system, however, would be its downfall.  This rush led to an extreme crunch on the developers of this system leading to a commonality between these cases, proper testing.  On top of this, there was a gargantuan, ever evolving 800-page set of system requirements.  This shows just how out of control this development was.  Because of these reasons, what was delivered was a dead-on-arrival system of over 700,000 lines of extremely buggy code, wasting hundreds of millions of dollars.</p>
<p>All these examples show just how important a proper development cycle is for good software.  Ignoring software engineering techniques for a cheap system with a fast turnaround almost always results in catastrophic failure as shown in these cases.  With the lack of proper testing, management, and documentation, these systems fail in drastic ways.</p>
<h2>HW5: Chapter 4 and reflections</h2>
<h3>4.5</h3>
<p>The gas pump system shall debit the customer’s account after fuel is distributed. (The user may end fueling sooner than specified leading to a less than expected price.)</p>
<p>The ATM shall dispense cash in a method specified by the user if possible.  (The user may want lower bills rather than the minimum amount possible.)</p>
<p>The internet banking system should notify both parties of the transfer.  (This helps reduce fraud or accidental transfers.)</p>
<h3>4.6</h3>
<p>To keep track of functional and non-functional system requirement relationships, an engineer should have a properly ordered software requirements specification that is easy to keep track of the sections so that the requirements can be simply understood with requirements related to system properties distinguished.</p>
<h3>4.7</h3>
<p>An account holder, using the ATM can view their account balance.  They can also decide whether to withdraw or deposit into this account and specify the amount.  Those with shared account access can also do this, however, they may not edit account details and must abide by restrictions set by the account holder and the bank.  These interactions are all tracked and shared with the account holder.</p>
<h3>Reflections</h3>
<p>Because our memories are flawed and cannot keep track of everything, development should be done in a methodical manner to ensure successful software.  Test Driven Development is one example of this to ensure code that works.  It also encourages code to be clean and well documented so that adjustments can be made frequently.  Having a thorough development process such as this can help reduce problems down the line.  One example of such an event that could be avoided is the lack of cybersecurity in new software in vehicles.  With minimal done in the way of encryption, these systems were found extremely easy to take advantage of, leading to new laws for the sake of safety.</p>
<h2>HW6: Chapter 2</h2>
<h3>2.1</h3>
<p>An antilock braking system would most appropriately use the waterfall model as it includes critical safety features that require thorough and complete analysis and complete specification and design documents.</p>
<p>Incremental development would be most appropriate for a virtual reality system so that feedback can be received by users and features can be added along the way as specifications change.</p>
<p>For a system that is being replaced, a reuse-oriented development would be appropriate as many of the requirements and features are already laid out instead of making everything from scratch.</p>
<p>For an interactive travel system, incremental development would be appropriate as feedback can be received by users and features can be added later.</p>
<h2>HW7: Chapter 5 and 6</h2>
<h3>5.3</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-3.png" alt="5.3" width="786" height="641">
<h3>5.5</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-5.png" alt="5.5" width="531" height="322">
<h3>5.7</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-7.png" alt="5.7" width="701" height="161">
<h3>5.8</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-8.png" alt="5.8" width="532" height="351">
<p>You may want to create both sequence and activity diagrams to see both the normal data flow of the system and the object interaction.</p>
<h3>6.4</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/6-4-1.png" alt="6.4.1" width="761" height="471">
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/6-4-2.png" alt="6.4.2" width="761" height="471">
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/6-4-3.png" alt="6.4.3" width="691" height="509">
<h2>HW8: Mythical Man Month</h2>
<p>One of the most overlooked aspects of software development is the creation of an accurate and efficient schedule.  Brooks’s “The Mythical Man-Month” focuses on this issue and its causes and possible solutions.  This book tackles this very important issue that purveys to this day all the way back in 1975.  While many problems have been solved due to the advent of technology since then, this only gives way to more complex problems and programs to be developed.  In this way, this book still gives a useful insight into why scheduling problems occur in the field.</p>
<p>As for why these scheduling issues occur, Brooks narrows it down to a few categories.  First is optimism in which people plan for nothing to go wrong during development, leaving little room for issues that are bound to happen in accordance with Murphey’s Law.  This goes hand-in-hand with the other issue of a severe lack of planned testing time.  With this lack of planned testing time, often software gets pushed out much too early where it is harder to fix while it is deployed.  Brooks suggests that managers should realistically plan for half of development time to be devoted to testing and debugging.  He says that this is not done, however, as many times schedulers lack guts in putting this time for inevitable problems into the schedule as to not look bad, even though severe delays would look far worse.</p>
<p>We then come to the namesake of the book, “The Mythical Man-Month,” this refers to the fallacy of thinking that extra manpower is equivalent to a whole month of development.  This is often a problem of development that is already off schedule, thinking that adding more workers will offset the delays.  As Brooks states it in his Law, “Adding manpower to a late software project makes it later.”  New workers will need systems training which will take time from those who need to teach them.  Brooks also argues that since communication must occur between those in a project, there is a sweet spot for a balance of manpower and overbearing communication issues.  This is why a small team of skilled programmers can often be as efficient, if not more, than a large team of average programmers.</p>
<p>For many large-scale projects, however, this is just not practical.  This is why Brooks speaks on the importance of a cohesive vision for a project as to not get bogged down in everchanging requirements and features.  Mill’s proposal mentioned here is one possible solution mentioned.  It suggests that a team should only have one lead programmer with the rest of the team there to support them as much as possible.  Some of the roles proposed here are nearly irrelevant due to strides in technology since this book was written, but it still holds useful ideas in how a project can support a cohesive vision in complex projects.</p>
<p>This book, while having some talking points since outdated, is still a great look into the problems of scheduling in software development and possible ways to deal with them.  Software engineering is a relatively new but ever-growing field that is held back by its inherent complexity as described by Brooks in his other essay “No Silver Bullet.”  This newness, however, allows us to see the fast development since our near past to still help solve problems in the field today.</p>
<h2>HW9: Chapter 8 and reflections on testing</h2>
<h3>8.7</h3>
<p>John is a park ranger.  During the summer he must keep a close look on the weather to evaluate the risk of wildfires.  On a normal workday he logs into the system and checks the local weather.  Today is a rather hot and dry day with a moderate risk of a wildfire spreading.  He submits the risk level to the system so that the park can take adequate precautions.</p>
<h3>8.10</h3>
<h3>Reflections on testing</h3>
