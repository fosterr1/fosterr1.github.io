---
layout: default
---
<h1>Reid Foster</h1>
<p>Blog for CSCI 362.</p>
<h2>HW0: Introduction</h2>
<p>I am from Hilton Head Island and am a third year Computer Science major at the College of Charleston.</p>
<h2>HW1: Chapter 1</h2>
<h3>1.3</h3>
<p>A software should have the attributes of acceptability, dependability and security, efficiency, and maintainability.  Other attributes that are beneficial to software are: compatibility to work on several different devices, scalability to be able to apply the functions of the software to a wide array of different things, portability to move the software and its data to another device, and upgradability to be able to update the software with new functions and fix bugs in an efficient manner.</p>
<h3>1.8</h3>
<p>The problem with licensing software engineers in the same way as doctors and lawyers is that many software engineers are self-taught to great effect and should not be discounted.  There is also already the fact that those with a degree or other certificate of training are already boosted in the view of employers as they already have that certainty of training unlike those who are self-taught.</p>
<h3>1.9</h3>
<p>1. Engineers should not intentionally hide information on what a software may do such as data collection.</p>
<p>2. Engineers should not put any backdoors or such in a system they are working on to later use themselves against a client.</p>
<p>3.  Engineers should ensure the security of a system such that hackers could not take advantage of it.</p>
<p>4. Engineers should not leak any confidential data for their own gain or the express intent of hurting the client.</p>
<p>5.  Managers should abstain from unjust work practices such as intense crunch time to finish a product.</p>
<p>6.  Engineers should act in a way that does not make the profession seem completely immoral such as working for an immoral employer.</p>
<p>7.  Engineers should not blame mistakes on colleagues unjustly to get ahead.</p>
<p>8.  Engineers should always be learning such to improve their work and get ahead of new security threats and the like.</p>
<h3>1.10</h3>
<p>The ethics involved in the creation of a system to constantly track citizens is essentially none.  The excuse of “fighting terrorism” can be used to drastically increase control over people and their daily lives.  Even if the morals of the users are completely just, the possibility of a malicious user is more than enough reason to not create a system that can be taken advantage of to a drastic degree. </p>
<h2>HW2: Reflections on software engineering practices</h2>
<p>The overarching problem throughout software development history is the extreme complexity in the creations of new systems.  It is a constant struggle to find new ways to reduce this complexity without losing something else along the way.  As seen in Brooks’s 1986 article, “No Silver Bullet,” many of the problems we face today in software engineering have been there since the very beginning.  The progression from the beginning to now can be seen in Potvin and Levenberg’s, “Why Google Stores Billions of Lines of Code in a Single Repository,” as while many issues have been solved by modern advances, the core problems of software engineering have only been scaled up to the monolithic projects of today such as Google.</p>
<p>As Brooks argues, complexity is inherent in the field of software engineering due to its uniqueness.  Because of this, software falls behind the incredible growth of computer hardware according to Moore’s Law.  And while computer hardware grows at an incredible rate compared to any field, software development continues slowly as it is quite unique compared to most anything else.  This is due to the difficulties that arise in the conception of software.  Most software has many unique elements that interact with each other in a nonlinear fashion, making visualization of software incredibly difficult.  This inherent “unvisualization” as Brooks calls it is why software engineering is so different than the development of other fields.  The development of things other than software almost always have a visualization and modeling step to plan the future steps of the project from the very beginning so that one understands the goals of the project.  This uniqueness hinders the conception of software and lends heavily to the inherent complexity of the field.</p>
<p>This complexity of non-linear interaction is seen on a terrific scale with the billions of lines of code seen in Google’s repository.  While there are many employees to comb through this code and automated systems set up for maintenance of this huge structure, complex problems are bound to happen this this large of a system.  Code-discovery is inherently difficult as many things that may have already been written could be rewritten somewhere else by one who does not know of the other’s existence in the billions of lines of code, wasting time and space.  And when code is found a large unwieldy web of dependencies can be formed through the interaction of all the code found within the structure.  This is somewhat alleviated with automated systems and code review to help ensure clean code alongside truck-based development to always keep everyone up to date on system changes.</p>
<p>In Neville-Neil’s “Cherry-Picking and the Scientific Method,” he makes two points about having small incremental merges rather than a single large one and approaching bug fixing like the scientific method with written thoughts on the problem.  These types of development philosophies can be seen on a large scale with Google’s repository and their trunk-based development to keep all employees up to speed with code changes.  This along with their automated systems of maintenance follow along with Brooks and his predictions for possible solutions to help alleviate software development complexity on a large scale as seen in the modern day.</p>
<h2>HW3: Chapters 11 & 12</h2>
<h3>11.4</h3>
<p>Architectural styles that are geared toward software fault tolerance all rely on some level of redundancy and software diversity.  This greatly improves reliability in the event of a system failure where there will be a transfer to a different system.</p>
<h3>11.7</h3>
<p>N-version programming would be useful for a critical machine such as one used for radiation therapy because in the event of a system failure the others can be relied on.  There is also some amount of self-moderation through the voting system that compares the outputs of each software diverse system to help ensure the correct output.</p>
<h3>11.9</h3>
<p>You should handle all exceptions in a system to ensure availability as otherwise a system fault is inevitable.  Handling exceptions will greatly reduce the number of possible system faults and keep the system available, otherwise, an exception could cause the system to fail and need to be fixed, leading to a large impact on availability.</p>
<h3>12.5</h3>
<p>Based off of these specifications, some system requirements for this software could be:  determine at what distance and rate the breaks should be applied to ensure a steady ride without extreme stops, make sure transmissions have a fast refresh rate to ensure that information on the system is current and correct, calculate routes based off of speed limits and signal status, decrease acceleration when approaching the speed limit, and be able to receive special warnings about any other dangers that require slowing or stopping the train.</p>
<h2>HW4: Reflections on software failures</h2>
<p>While software has been a great boon in the advancement of technology, this overreliance has led to many catastrophic accidents.  This overreliance has led to overconfidence on several occasions, further leading to general disregard for good software engineering practices.  Even in systems where the reliability of the software is paramount for the safety of many, this disregard can be seen.  Often the ignorance towards productive software development leads to many problems, such as: poor management, buggy, poorly tested code, a complete lack of documentation for later analysis, a rushed schedule, teams that are too small and overworked, and more.</p>
<p>One example of the overreliance and overconfidence in software is the Therac-25 accidents which led to several injuries and deaths.  This overconfidence led to the removal of the hardware safety features in this new machine.  However, the software was based off these previous versions that had the hardware safety features, and as it turns out, this software already had bugs that went unnoticed because they were previously covered by hardware mechanisms.  Not only that, there was supposedly only one developer who could not be discovered after the accidents.  The resulting code was severely lacking documentation.  And when engineers tested the machines, the software was an afterthought and essentially ignored.</p>
<p>This relates to another issue, the lack of proper user interface development.  With the Therac-25 case in the 1980s and the one of overdosing CT scans in the 2000s, both had user interface problems which further exacerbated the problems.  Both cases had several examples in which the operators of the machines did not have a substantial amount of information on how to properly manage the systems, with severely lackluster manuals.  There were error codes with no explanations that also had no indications of how dangerous it was.  Along with that, the CT scans had an automatic feature that raised the dosage on a patient due to improper explanation of its intended function.  This total disregard for a clear interface on a system so crucial is a major oversight.</p>
<p>Perhaps the most important thing that was ignored in these cases was proper management to ensure a healthy development cycle.  This can be seen no better than in the FBI’s transitioning to an electronic case system.  After 9/11, the FBI’s system of information was seen to be extremely lacking and was obvious in need of a substantial overhaul.  This rush for a new system, however, would be its downfall.  This rush led to an extreme crunch on the developers of this system leading to a commonality between these cases, proper testing.  On top of this, there was a gargantuan, ever evolving 800-page set of system requirements.  This shows just how out of control this development was.  Because of these reasons, what was delivered was a dead-on-arrival system of over 700,000 lines of extremely buggy code, wasting hundreds of millions of dollars.</p>
<p>All these examples show just how important a proper development cycle is for good software.  Ignoring software engineering techniques for a cheap system with a fast turnaround almost always results in catastrophic failure as shown in these cases.  With the lack of proper testing, management, and documentation, these systems fail in drastic ways.</p>
<h2>HW5: Chapter 4 and reflections</h2>
<h3>4.5</h3>
<p>The gas pump system shall debit the customer’s account after fuel is distributed. (The user may end fueling sooner than specified leading to a less than expected price.)</p>
<p>The ATM shall dispense cash in a method specified by the user if possible.  (The user may want lower bills rather than the minimum amount possible.)</p>
<p>The internet banking system should notify both parties of the transfer.  (This helps reduce fraud or accidental transfers.)</p>
<h3>4.6</h3>
<p>To keep track of functional and non-functional system requirement relationships, an engineer should have a properly ordered software requirements specification that is easy to keep track of the sections so that the requirements can be simply understood with requirements related to system properties distinguished.</p>
<h3>4.7</h3>
<p>An account holder, using the ATM can view their account balance.  They can also decide whether to withdraw or deposit into this account and specify the amount.  Those with shared account access can also do this, however, they may not edit account details and must abide by restrictions set by the account holder and the bank.  These interactions are all tracked and shared with the account holder.</p>
<h3>Reflections</h3>
<p>Because our memories are flawed and cannot keep track of everything, development should be done in a methodical manner to ensure successful software.  Test Driven Development is one example of this to ensure code that works.  It also encourages code to be clean and well documented so that adjustments can be made frequently.  Having a thorough development process such as this can help reduce problems down the line.  One example of such an event that could be avoided is the lack of cybersecurity in new software in vehicles.  With minimal done in the way of encryption, these systems were found extremely easy to take advantage of, leading to new laws for the sake of safety.</p>
<h2>HW6: Chapter 2</h2>
<h3>2.1</h3>
<p>An antilock braking system would most appropriately use the waterfall model as it includes critical safety features that require thorough and complete analysis and complete specification and design documents.</p>
<p>Incremental development would be most appropriate for a virtual reality system so that feedback can be received by users and features can be added along the way as specifications change.</p>
<p>For a system that is being replaced, a reuse-oriented development would be appropriate as many of the requirements and features are already laid out instead of making everything from scratch.</p>
<p>For an interactive travel system, incremental development would be appropriate as feedback can be received by users and features can be added later.</p>
<h2>HW7: Chapter 5 and 6</h2>
<h3>5.3</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-3.png" alt="5.3" width="786" height="641">
<h3>5.5</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-5.png" alt="5.5" width="531" height="322">
<h3>5.7</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-7.png" alt="5.7" width="701" height="161">
<h3>5.8</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/5-8.png" alt="5.8" width="532" height="351">
<p>You may want to create both sequence and activity diagrams to see both the normal data flow of the system and the object interaction.</p>
<h3>6.4</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/6-4-1.png" alt="6.4.1" width="761" height="471">
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/6-4-2.png" alt="6.4.2" width="761" height="471">
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/6-4-3.png" alt="6.4.3" width="691" height="509">
<h2>HW8: Mythical Man Month</h2>
<p>One of the most overlooked aspects of software development is the creation of an accurate and efficient schedule.  Brooks’s “The Mythical Man-Month” focuses on this issue and its causes and possible solutions.  This book tackles this very important issue that purveys to this day all the way back in 1975.  While many problems have been solved due to the advent of technology since then, this only gives way to more complex problems and programs to be developed.  In this way, this book still gives a useful insight into why scheduling problems occur in the field.</p>
<p>As for why these scheduling issues occur, Brooks narrows it down to a few categories.  First is optimism in which people plan for nothing to go wrong during development, leaving little room for issues that are bound to happen in accordance with Murphey’s Law.  This goes hand-in-hand with the other issue of a severe lack of planned testing time.  With this lack of planned testing time, often software gets pushed out much too early where it is harder to fix while it is deployed.  Brooks suggests that managers should realistically plan for half of development time to be devoted to testing and debugging.  He says that this is not done, however, as many times schedulers lack guts in putting this time for inevitable problems into the schedule as to not look bad, even though severe delays would look far worse.</p>
<p>We then come to the namesake of the book, “The Mythical Man-Month,” this refers to the fallacy of thinking that extra manpower is equivalent to a whole month of development.  This is often a problem of development that is already off schedule, thinking that adding more workers will offset the delays.  As Brooks states it in his Law, “Adding manpower to a late software project makes it later.”  New workers will need systems training which will take time from those who need to teach them.  Brooks also argues that since communication must occur between those in a project, there is a sweet spot for a balance of manpower and overbearing communication issues.  This is why a small team of skilled programmers can often be as efficient, if not more, than a large team of average programmers.</p>
<p>For many large-scale projects, however, this is just not practical.  This is why Brooks speaks on the importance of a cohesive vision for a project as to not get bogged down in everchanging requirements and features.  Mill’s proposal mentioned here is one possible solution mentioned.  It suggests that a team should only have one lead programmer with the rest of the team there to support them as much as possible.  Some of the roles proposed here are nearly irrelevant due to strides in technology since this book was written, but it still holds useful ideas in how a project can support a cohesive vision in complex projects.</p>
<p>This book, while having some talking points since outdated, is still a great look into the problems of scheduling in software development and possible ways to deal with them.  Software engineering is a relatively new but ever-growing field that is held back by its inherent complexity as described by Brooks in his other essay “No Silver Bullet.”  This newness, however, allows us to see the fast development since our near past to still help solve problems in the field today.</p>
<h2>HW9: Chapter 8 and reflections on testing</h2>
<h3>8.7</h3>
<p>John is a park ranger.  During the summer he must keep a close look on the weather to evaluate the risk of wildfires.  On a normal workday he logs into the system and checks the local weather.  Today is a rather hot and dry day with a moderate risk of a wildfire spreading.  He submits the risk level to the system so that the park can take adequate precautions.</p>
<h3>8.10</h3>
<p>In an important system, if thorough systems testing is not fully carried out, dangerous emergent behavior could occur.  Because some aspects of the system may not become obvious before components are put together, an unthorough testing cycle could miss crucial details before deployment.  Giving this to external customers would be unethical as they would likely be unaware of these possible issues.</p>
<h3>Reflections on testing</h3>
<p>Testing is an extremely important aspect of software development.  Therefore, many say that it takes up half of all development time.  A lack of testing can lead to a completely failed launch of a product if there are a vast number of bugs at release.  However, this happens quite frequently due to either lack of budget or an inflexible schedule.  Bugs are inevitable in every program, even with great code; testing is for finding all these hidden bugs to deliver a satisfactory product. Testing should never be overlooked in the development process as it is vital to success.</p>
<h2>HW10: Chapter 15</h2>
<h3>15.10</h3>
<p>The ethics of code reuse along with copyright is a conundrum.  If a company creates a system for one company and then is contracted to create a similar system for another, what should they do?  If some aspect of the project is already developed and can be reused, why put in all the development time in making a completely new system?  If almost the entire project is the same, what then?  These are important questions for software development.  One possible solution would be for the contractor to develop a generic system and license out specific versions to companies based off their needs.  But what if that company reuses parts of the code in their own software?  This would mean that the contractor’s work is being used without their input or imbursement.  This would be unethical if the company did not have full rights to the code.  These many issues are something that should be clearly stated to both parties in the contract they have together so that terms are agreed upon.</p>
<h2>HW11: Chapter 9</h2>
<h3>9.8</h3>
<p>The three main types of software maintenance are fixing errors in the program, adapting the program to a new environment, and adding new functions to the program.  It can be difficult to distinguish between them due to the fact that they can often occur at the same time.  You may add new functionality when adapting to a new system or avoid system faults by reworking parts of the system to avoid them for example.</p>
<h3>9.10</h3>
<p>It is often the case where engineers have no incentive to develop easily maintainable code.  After the project they may be moved to a different one with another team devoted to program maintenance.  This does not mean they should not have maintainable code, however.  It will reflect poorly on them as a programmer if their code is incomprehensible to those who may work on it in the future, as well as having the possibility of terrible results such as the case in the Therac-25 incidents where the poorly written code made it very difficult to decern the problems that resulted in several deaths.</p>
<h2>HW12: Chapter 16</h2>
<h3>16.9</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/16-9.png" alt="16.9" width="564" height="601">
<h2>HW13: Chapter 17</h2>
<h3>17.10</h3>
<p>One risk of switching to a service would be lack of control over the evolution of that software.  The software provider can change the software whenever they wish.  One way to reduce this risk would be for the software to have a high degree of configurability so that any company may adjust for their own needs rather than making specific tools for specific users.  Another risk would be server overload.  While significantly reduced by using web technologies, this is still a problem today when services do not have a good degree of scalability.  This risk could be reduced by the service by having scalability techniques such as asynchronous interaction or fine-grain locking.  Another risk would be that of relying on a third party to protect and store your data.  To reduce this risk the company must ensure the transfer of data to a remote service is in accordance with their laws.  The service should reduce risk by having sufficient cybersecurity measures as well as having a good multi-tenancy implementation.</p>
<h2>HW14: Chapter 18</h2>
<h3>18.4</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/18-4.PNG" alt="18.4" width="636" height="419">
<h2>HW15: Chapter 19</h2>
<h3>19.3</h3>
<p>It is impossible to infer the emergent properties of a complex system from the properties of the system components due to the unexpected ways in which the components may interact.  A failure in one component may drastically affect another in a snowball effect.  Each of the components on their own will have inherent complexity interacting with itself; adding several of these together to create a system increases this complexity much further.  Such as the case with the Therac-25 incidents in which removing the hardware safety measures to rely on the software led to disastrous consequences due to the software being based off of previous systems that included these fail-safes led to learning the software had bugs that were no issue previously due to these fail-safes but were not accounted for in the new system.</p>
<h2>HW16: Chapter 20</h2>
<h3>20.10</h3>
<p>This tactic is unethical no matter how you look at it.  The company’s employees must actively change a working product into a more complex, confusing version to trick users into spending more.  The customers of this product will have to quickly adjust to the sudden changes, possibly putting a halt to their system as they must change their own product to adapt to the new interfaces.  The shareholders may be happy with possible increased profits, but that does not excuse this underhanded tactic.  In fact, a change such as this will make customers lose faith in the company with the possibility of avoiding their products and moving to the competition.  This may result in short-term profits, but will dramatically affect the long-term as customer trust will need to be regained.</p>
<h2>HW17: Team Progress I</h2>
<p>Our team has been making adequate progress on the project.  Each deliverable has its own challenges, but we have been moving along at a steady pace.  There have been many new coding experiences working on this project.  Our code has interactions between python, java, bash, and html.  Creating this interaction has been an interesting new experience.  This is also my first use of the java package system.  It gave me a lot of trouble figuring out the nuances of this system, but I expect that knowledge to benefit me greatly in the future.  Working extensively with the several aspects of GitHub is also a good experience, using new features such as the wiki and pages.  Overcoming all these new experiences has been challenging but we have been very successful in doing so.  I expect this pace to continue through the rest of the project, if not pick up considering our project framework has been constructed.</p>
<h2>HW18: Chapter 21 and Chapter 22</h2>
<h3>21.4</h3>
<p>Because real-time systems have strict timing constraints, object-oriented development may not be suitable.  Object-oriented programing involves encapsulation with extra code overhead with defined objects.  This overhead can lead to a significant performance hit for strict real-time systems.</p>
<h3>22.6</h3>
<p>The use of such a contract leaves a high risk of budgetary issues due to contractors bidding with lower development prices.  This issue would have to be resolved by sacrificing important parts of development, whether it be staff turnover, delays, or underperformance.  In a worst-case scenario, the contractor could go under and not deliver the product.  Budgets are often underestimated in development, and a fixed price cost would exacerbate this issue.</p>
<h2>HW19: Chapter 23</h2>
<h3>23.6</h3>
<img src="https://raw.githubusercontent.com/fosterr1/fosterr1.github.io/master/assets/23-6.png" alt="23.6" width="1514" height="936">
